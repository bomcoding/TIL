# JAVA
> [책 자바의 정석(남궁성)](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&barcode=9788994492032)을 정리한 내용입니다.


## 객체지향개념1

* 객체지향특징
```
- 코드의 재사용성이 높다.
- 코드의 관리가 용이하다.
- 신뢰성 높은 프로그래밍을 가능하게 한다.(중복제거)
```
* 클래스
```
- 객체를 만드는데 사용하는 설계도, 틀.
```
* 객체
```
- 클래스에 정의된 대로 생성된 것.
```
* 변수
```
- cv (클래스 변수) : 같은 클래스의 모든 인스턴스들이 공유하는 변수.
- iv (인스턴스 변수) : 개별적인 변수.
- lv (지역 변수) : 메서드 or 블럭이 종료될 때까지만 사용하는 변수.
```
* 메서드_명령문의 집합
```
- 높은 재사용성
- 중복된 코드제거
- 프로그램의 구조화
```
* JVM 메모리구조
```
- 메서드 영역 : 클래스 정보와 변수저장공간.
- 호출스택 : 메서드 작업공간.
- 힙 : 인스턴스가 생성되는 공간.
```
* 재귀호출
```
- 메서드 내에서 자신을 반복적으로 호출.
```
* 매개변수(보조변수)
```
- 기본형 매개변수 : 변수의 값을 읽기만 할 수 있다.
- 참조형 매개변수 : 변수의 값을 읽고 변경 할 수 있다.
- 매개변수 유효성 검사 : 매개변수의 값이 적절한 것인지 확인한다.
```
* 가변인자
```
- 내부적으로 배열을 이용하는 것.
```
* 인스턴스 메서드
```
- 메서드 작업을 하는데, 인스턴스 변수를 필요로 하는 메서드.
```
* 클래스 메서드
```
- 인스턴스와 관계없는 메서드를 static메서드로 정의.
```
* 오버로딩
```
- 한클래스 내에 같은 이름의 메서드 여러개를 정의하는 것.
```
* 오버로딩의 조건
```
1. 메서드 이름이 같아야 한다.
2. 매개변수의 개수 또는 타입이 달라야 한다.
3. 리턴타입이 다른 경우에는 성립되지 않는다.
```
* 생성자
```
- 인스턴스 초기화 메서드
```
* 생성자의 조건
```
1. 생성자의 이름은 클래스의 이름과 같아야 한다.
2. 생성자는 리턴값이 없다.
3. 다른 생성자 호출할 때, 첫 줄에 입력해야한다.
4. 모든 클래스는 반드시 생성자가 1개는 있어야 한다.
```
* 생성자에서 다른 생성자 호출하기
```
- 클래스 이름대신 this를 사용한다.
- 다른 생성자를 호출할 때 반드시 첫 줄에만 호출이 가능하다.
```
* this와 this() 비교
```
- this : 인스턴스 자신을 가리키는 참조변수. 인스턴스 주소가 저장되어 있다.
- this() : 생성자, 같은 클래스의 다른 생성자를 호출 할 때 사용.
```
* 초기화 
```
- 변수를 선언하고 처음으로 값을 저장하는 것.
- 지역변수는 초기화가  필수적이다.
```
* 초기화 순서
```
1. 기본값 (static)
2. 명시적 초기화 (static)
3. 클래스 초기화 블럭
4. 기본값 (instance)
5. 명시적 초기화 (instance)
6. 인스턴스 초기화 블럭
7. 생성자 (instance)
```

### 심화정리

* 객체 배열
```
- 배열안에 객체의 주소가 저장된다.
- 참조변수들을 하나로 묶은 참조변수 배열이다.
- 다형성을 이용해 여러타입의 객체를 저장할 수도 있다.<br>
```
``` Tv[] tvArr = {new Tv(), new Tv(), new Tv()};```

* 클래스의 정의
```
1. 클래스 - 객체를 생성하기 위한 틀
2. 클래스 - 데이터와 함수의 결합
	- 서로 관련된 변수들을 정의하고 이들에 대한 작업을 수행하는 함수들을 함께 정의한 것이다.
3. 클래스 - 사용자정의 타입
	- 서로 관련된 변수들을 묶어서 하나의 타입으로 새로 추가하는 것.
```
```
class Time{
	int hour;
	int minute;
	float second;
	  }//사용자 정의타입(Time)에 여러 변수를 선언
```

* 인스턴스변수
```
- 클래스 영역에 선언
- 변수의 값을 읽거나 저장할 때 먼저 생성해 놓아야 한다.
- 독립적인 저장공간을 가지므로 서로 다른값을 가진다.
```
* 클래스변수
```
- 인스턴스변수 앞에 static을 붙인다.
- 저장공간을 공유한다. 때문에 공통된 값을 유지한다.
- 인스턴스를 생성하지 않고 언제라도 사용할 수 있다.
- public을 앞에 붙이면 전역변수로 사용가능하다.
```
* 지역변수
```
- 메서드 내에 선언되어 메서드 내에서만 사용가능하다.
- 메서드가 종료되면 변수도 소멸된다.
- for, while문 안에서 선언하면 {}블럭 안에서만 사용가능.
```
* 메서드의 구성
```
1. 메서드 선언부
	- 메서드 이름, 매개변수 선언, 반환타입으로 구성됨.
	- 메서드 선언부를 변경하면, 호출되는 곳도 같이 변경.
2. 매개변수 선언
	- 메서드가 작업하는데 필요한 값을 선언.
	- 타입을 생략할 수 없다.
	- 입력받을 값이 없으면 생략가능.
3. 메서드 구현부
	- 메서드를 호출 했을 때 수행되는 문장들.
4. 반환타입return문)
	- 메서드 결과를 반환하려면 값의 타입이 선언부의 타입과 동일하거나 자동형변환이 가능한 것이야 한다.
	- 반환값이 없다면 ‘void’를 적어야 한다.
5. 지역변수
	- 메서드 내에서 선언된 변수들.
	- 메서드 내에서만 사용되므로 다른메서드에서 같은이름의 변수선언가능.
6. 메서드 호출방법
	- 메서드이름(값1, 값2, ....); //반환타입이 있는경우 이름앞에 지정
7. 매개변수의 유효성 검사
	- float타입을 반환하는데 나누는 값이 0이면 안돼기 때문에 if문을 사용해 값이 0인지 확인해야한다. 
```
```
int(반환타입) add(메서드 이름)(int x, int y)(매개변수 선언){
      int result = x + y;
      return result;(반환값:반환타입과 같은 타입의 변수)
}
```

*****


## 객체지향개념2

* 상속
```
→ 기존 클래스를 재사용해 새로운 클래스를 작성. (단일 상속만 허용)
```
* 포함
```
→ 한 클래스의 멤버변수로 다른 클래스를 선언.
```
* Object클래스
```
→ 모든 클래스의 최고 조상
(toString, equals등 포함)
```
* 오버라이딩
```
→ 상속받은 메서드의 내용을 변경하는 것.
```
* 오버라이딩의 조건
```
선언부(이름, 매개변수, 반환타입)가 같아야 한다.
접근제어자는좁은 범위로 변경 할 수 없다.
조상클래스의 메서드보다 많은 수의 예외를 선언 할 수 없다.
```
* 참조변수
```
→ this : 인스턴스 자신을 가리키는 참조변수. 인스턴스 주소가 저장되어 있다.
→ super : this와 동일. 조상멤버와 자식멤버를 구별하는데 사용한다.
```
* 패키지
```
→ 관련된 클래스와 인터페이스의 묶음.
→ 패키지가 선언되지 않은 클래스는 자동적으로 default에 속한다.
```
* 클래스 패스
```
→ 클래스파일을 찾는 경로
```
* import문
```
→ 사용할 클래스가 속한 패키지를 지정하는데 사용.
```
* 제어자
```
→ 접근제어자
→ 그 외(static, final, abstract 등)
```
* 접근제어자
```
-public : 접근제한이 없다.
-protected : 같은 패키지와 다른패키지 자손클래스에서 접근가능.
-default : 같은 패키지 내에서만 접근
-private : 같은 클래스 내에서만 접근
```
* 접근제어자 사용이유
```
→ 외부로부터 데이터 보호
→ 외부의 불필요하고, 내부적으로만 사용되는 부분을 감추기 위해
```
* 그 외 제어자 사용범위
```
-static : 멤버변수, 메서드, 초기화 블럭
-fina : 클래스, 메서드, 멤버변수, 지역변수
-abstract : 클래스, 메서드
```
* 다형성
```
→ 조상타입 참조변수로 자손타입 객체를 다룰 수 있는 것. 
```
* 참조변수 형변환
```
→ 자손과 조상은 서로 형변환 가능. 자손끼리는 불가.
```
* instanceof 연산자
```
→ 참조변수가 참조하는 인스턴스 실제타입을 체크하는데 사용.
```
* 참조변수와 인스턴스변수의 연결
```
→ 메서드가 중복정의된 경우, 참조변수의 타입에 관계없이 항상 실제 인스턴스의 타입에 정의된 메서드가 호출된다.
```

*****

## 예외처리

* 정의와 목적
```
→ 정의 : 예외발생을 대비한 코드 작성
→ 목적 : 비정상 종료를 막고, 정상 실행상태를 유지
```
* 오류종류
```
컴파일 에러 : 컴파일시 발생에러
런타임 에러 : 실행 시 발생에러
논리적 에러 : 에러는 없어도 의도와 다른 결과출력
```
* 에러와 예외
```
→ 에러 : 코드로 수습될 수 없는 심각한 오류
→ 예외 : 코드로 수습될 수 있는 미약한 오류 
```
* 예외클래스
```
Exception클래스(최고조상, 필수처리)
→ 외적요인에 의해 발생하는 예외
RuntimeException클래스(선택처리)
→ 개발자의 실수로 발생하는예외
```
* try-catch(멀티 : 한줄에 여러 에러메시지 가능)
```
→ try{예외발생 예상코드}
catch(Exception종류){에러 발생시 처리코드}
```
* printStackTrace()
```
→ 예외발생 시 호출스택에 있던 메서드 정보와 예외메시지를 출력
```
* getMessage()
```
→ 발생한 예외클래스 인스턴스에 저장된 메시지를 얻는다.
```
* finally블럭
```
→ 예외발생 여부와 관계없이 실행되어야 하는 코드
→ return문을 만나도 finally실행
try→ catch→ finally순으로 실행
```
* 메서드에 예외선언
```
→ 메서드 선언부에 throws를 사용 후 발생예외를 적는다
→ 자손타입의 예외까지도 발생할 수 있음
→ 오버라이딩 할 때는 상속관계까지 고려해야함
```
* 자동 자원 반환_try-with-resources
```
→ 괄호()안에 객체를 생성하는 문장을 넣으면, 이 객체는 따로 close()를 하지 않아도 try블럭을 벗어나는 순간 자동적으로 close()가 호출된다.
```
* 예외 되던지기
```
→ 예외를 처리한 후 인위적으로 다시 발생
→ 여러에러를 try-catch와 메서드로 나누어 처리할 때 유용
```
* 연결된 예외
```
→ 한 예외가 다른 예외를 발생시킴
→ Throwable initCause(Throwable cause) 발생에러를 원인예외로 등록
→ Throwable getCause() //원인예외를 반환
```

*****


## 람다와 스트림

* 람다식
```
→ 메서드(함수)를 간단한 식으로
→ 익명함수(객체)
```
```
int max(int a, int b){         (int a, int b) -> 
  return a > b ? a : b;  →   return a > b ? a : b;
} 		                }
```
↓
```
(int a, int b) -> {return a>b ? a:b;} → (int a, int b) -> a>b ? a:b
```
↓
```
(int a, int b) -> a > b ? a : b → (a, b) -> a > b ? a : b
```
```
-익명객체
-함수형 인터페이스
-메서드 참조(클래스 이름::메서드 이름)
```
* 스트림
```
생성
중간연산 종류-skip(), limit( )
		-filter( ), distinct( )
		-sorted( )
		-map( ), flatMap( )
		-peek()
최종연산 종류-forEach( ), forEachOrdered( )
```

## 입출력(I/O)

* 스트림
```
→ 데이터가 입출력 되는 연결통로
→ 입출력을 동시에 수행하려면, 2개의 스트림 필요
```
* 바이트기반 스트림
	→ 데이터를 바이트(byte)단위로 주고 받음
```
	* InputStream, OutputStream
		→ 바이트기반 스트림의 최고조상
	* ByteArrayInputStream, ByteArrayOutputStream
		→ 바이트배열에 데이터를 입출력하는 스트림
	* FileInputStream, FileOutputStream
		→ 파일에 데이터를 입출력하는 스트림
```
* 바이트기반 보조스트림
	→ 독립적으로 입출력을 수행못함(기반스트림 필요)
```
	FilterInputStream, FilterOutputStream
		→ 모든 바이트기반 보조스트림의 최고조상
	BufferedInputStream, BufferedOutputStream
		→ 입출력을 효율을 높이기 위해 버퍼를 사용
	DataInputStream, DataOutputStream
		→ 기본형 단위로 읽고 쓰는 보조스트림
```
* 문자기반 스트림
	→ 입출력 단위가 문자인 스트림
```
	* Reader, Writer
		→ 문자기반 스트림의 최고조상
	* FileReader, FileWriter
		→ 텍스트 파일의 입출력에 사용
	* PipedReader, PipedWriter
		→ 쓰레드간의 통신에 사용
	* StringReader, StringWriter
		→ 메모리 입출력에 사용
```
* 문자기반 보조스트림
```
	* BufferedReader, BufferedWriter
		→ 입출력 효율을 위해 버퍼를 사용
		→ 라인(line)단위 입출력이 편리
	* InputStreamReader, OutputStreamWriter
		→ 바이트기반스트림을 문자기반스트림처럼 사용하게 해준다.
		→ 인코딩을 변환하여 입출력 할 수 있게 해준다.
```
* 표준 입출력과 File
```
	* 표준입출력-System.in, System.out, System.err
		→ 콘솔을 통한 데이터의 입출력을 뜻한다.
		→ JVM이 시작되면서 자동적으로 생성된다.
	* RandomAccessFile
		→ 하나의 스트림으로 파일에 입력과 출력을 모두 수행 가능한 스트림
		→ 다른 스트림과 달리 Object의 자손이다.
	* File(교재 참고)
```
* 직렬화
```
→ 객체를 연속적인 데이터로 변환. 반대는 ‘역직렬화’.
→ 객체의 인스턴스변수들의 값을 일렬로 나열.(저장을 위해)
	* ObjectInputStream, ObjectOutputStream
		→ 객체를 직렬화해 입출력하게 해주는 보조스트림
```

## 네트워킹

* 클라이언트/서버
	→ 서비스를 제공하는 것은 서버, 제공받는 것은 클라이언트.
	* 서버기반 모델
	```
		→ 안정적인 서비스 제공이 가능
		→ 공유데이터의 관리와 보안이 용이
		→ 서버구축비용과 관리비용이 높음
	```
	* P2P기반 모델
	```
		→ 서버구축, 운용비용 절감
		→ 자원활용 극대화
		→ 자원관리 어려움
		→ 보안이 취약
	```
* IP주소
```
→ 컴퓨터(호스트)를 구별하는 고유한 주소값
→ IP주소는 네트워크주소와 호스트주소로 구성
→ IP주소와 서브넷마스크를 ‘&’연산하면 네트워크 주소를 얻음
```
* URL - 파일경로
```
→ 인터넷 서버들의 자원에 접근 할 수 있는 주소.
→ 1)프로토콜, 2)호스트명, 3)포트번호, 4)경로명, 5)파일명, 6)쿼리, 7)참조 로 구성
```
* 소켓 프로그래밍
```
→ 소켓을 이용한 통신 프로그래밍
→ 소켓 : 프로세스간 통신에 사용되는 양쪽 끝단.
```
* OSI 7계층
```
물리계층 → 데이터링크계층 → 네트워크계층 
→ 전송계층 → 세션계층 → 표현계층 → 응용계층
```
* TCP/UDP
```
* 항목	
TCP							UDP
* 연결방식
-연결기반					-비연결기반
-1:1 통신방식				-1:1, 1:n, n:n 통신방식
* 특징		
-데이터의 경계 구분안함		-데이터의 경계 구분함
-신뢰성 있는 데이터 전송	-데이터 수신여부 미확인
-UDP보다 전송속도 느림		-TCP보다 전송속도 빠름
```
* 서버/클라이언트 실행 시 주의사항
```
→ 서버가 구동중이어야만 클라이언트가 접속 할 수 있다.
→ 클라이언트 소스코드에서 접속하고 싶은 ip주소를 입력해야 한다. ip주소는 cmd에서 ip config입력해 알 수있다.
→ 실행전에 반드시 Run configuration에서 Arguments안에 값을 넣어야 한다. 그 값은 기본 배열(arr[])의 값, 닉네임이다.
```

## 객체지향개념 시험

* 객체지향개념의 특징.
```
1) 코드의 재사용성이 높다
2) 코드의 관리가 용이
3) 신뢰성이 높은 프로그래밍을 가능
4) 캡상추다.(캡슐화, 상속, 추상화, 다형성)
```
* 생성자의 작성할 때 지켜야 하는 3가지 조건.
```
1) 생성자의 이름은 클래스의 이름과 같아야 한다.
2) 생성자는 리턴값이 없다.(void안붙임)
3) 생성자 첫줄에는 반드시 다른 생성자를 호출해야 한다.(아니면 super(); 자동추가)
4) 모든 클래스는 반드시 생성자가 1개는 있어야 한다.
[정의] 인스턴스를 초기화하는 메서드.
```
* 오버라이딩 할 때 지켜야 할 3가지 조건을 적으시오.
```
1) 선언부가 같아야 한다. (이름, 매개변수, 리턴타입)
2) 접근제어자는 좁은 범위로 변경 할 수 없다.
3) 많은 수의 예외를 선언할 수 없다.
[정의] 상속받은 메서드의 내용을 변경.
```
* 오버로딩 할 때 지켜야하는 3가지 조건.
```
1) 메서드 이름이 같아야 한다.
2) 매개변수의 개수 또는 타입이 달라야 한다.
3) 리턴타입이 다른 경우에는 성립되지 않는다.
정의) 한 클래스 내에 같은 이름의 메서드 여러개를 정의 하는 것.
```
* 다형성의 장점 2가지.
```
1) 하나의 배열에 여러타입 객체 저장.
2) 매개변수의 다형성{void buy(Product p)}
정의) 조상타입 참조변수로 자손타입 객체를 다룰 수 있는 것.
```
* static메서드가 같은 클래스의 인스턴스 변수를 사용할 수 없는 이유.
```
-static메서드가 호출되었을 때, 인스턴스가 생성되었는지 알 수 없기 때문.
```
* 메서드 aaa()의 반환타입이 인터페이스 Runnable일 때, 이 메서드가 반환해야 하는 값은?
```
-인터페이스를 구현한 클래스의 객체를 반환한다.
```
* 객체를 생성했을 때, 객체가 초기화되는 과정순서.
```
- static멤버 명시적 초기화 -> 생성자 -> static초기화 블럭 -> 인스턴스 명시적 초기화 -> 생성자 -> 인스턴스 초기화 블럭
```
* 접근제어자를 접근 범위가 제일 넓은 것부터 순서대로 적으시오.
```
public  >  protected  >  default  >  private
```	
* 인터페이스와 추상 클래스의 차이
```
→ 인스턴스변수를 가질수 있느냐 없느냐이다.
```